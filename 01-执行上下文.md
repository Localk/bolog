# 二、执行上下文

### 1.执行上下文

执行上下文，在运行代码时，被压入执行栈。

### 2.创建执行上下文

执行上下文，也叫执行环境（execution content），分为全局执行环境，和函数执行环境。能决定函数或者变量能访问的数据。
执行上下文，包含如 变量对象/活动对象、作用域链、this的值 这三部分（是否有其他的组成部分不清楚）：

```javascript
execution_context = {
    variable_object = { ... } ;  //变量对象，在函数执行环境中，是活动对象
    scope_chain = [...] ;   // 作用域链
    thisValue = {...}   // this的指向
}
```

在web浏览器中，全局执行环境，被指定为 Windows。

### 3、变量对象/活动对象

- 变量对象：在创建执行上下文时，用来存储已声明的变量和函数。这个过程，就是声明提升的过程。
- 活动对象：其实也是变量对象，只不过是在函数调用时，出现在函数的执行上下文中。只有在函数被调用时，才会被激活，然后使用函数的arguments 对象，来初始化。

变量对象（活动对象也是变量对象）的出现，说明在执行环境中（全局执行环境或者局部执行环境）有一个存储着变量和函数的对象。

### 4、作用域链

代码在一个环境中执行时，会创建变量对象的作用域链（数组或者是类数组对象）。作用域链按照一定的顺序，存储不同级别（父级或者父父级）的变量对象。在访问时，也需要按照一定的顺序，来访问作用域链，以此保证当前环境对变量和函数的有序访问。如果这个环境，是函数执行上下文（也就是函数被调用时），则创建活动对象，添加到作用域链中。

函数在被声明时，会使用一个私有变量`[[Scope]]`，来存储当前全局的作用域链。当函数被调用时，再创建当前函数的活动对象。然后在创建函数自己的作用域链。在创建函数自己的作用域链时，先把自己的活动对象，添加在作用域链的前面，然后复制所持有的`[[Scoped]]` 属性（存储的是上级的作用域链，包含上级的活动对象，和全局变量对象），将复制出来的上级作用域链，插入到函数自己的作用域链后面。

```javascript
// 0. 假设已存在全局执行环境
/*
    global_exContext = {
        variable_obj = {...} , // 存储了全局的活动对象
        scope_chain = [variable_obj]; // 作用域链
        this .... // this的指向
    }
*/


function f1(){ return f2(){} };
//1 . 函数声明时：
/*  在全局的变量对象中，有一个 f1,指向的是函数的存储地址
    f1的 [[Scope]] 属性，指向了当前声明函数时，所在执行环境的作用域链
 */

var a = f1();
// 2. 函数调用时
/*
    创建函数的执行上下文：
        fn_exContext = {
            variable_obj : object active, // 执行环境，存储活动对象,使用arguments初始化
            scope_chain:[ object_active , f1.[[Scope]] ] // f1.[[Scope]] 是打散，还是直接添加，不太清除？？
            this ... // this的指向
        }

*/

a();
// 3. 函数闭包
/*
    创建函数的执行上下文：
        fn_exContext = {
            variable_obj : object active, // 执行环境，存储活动对象,使用arguments初始化
            scope_chain:[ object_active , f2.[[Scope]] ] // f2.[[Scope]] 是打散，还是直接添加，不太清除？？
            this ... // this的指向
        }

    执行环境中， f2.[[Scope]] ， 存储的是一个作用域链，指向的是f1的作用域链，所以包含了f1和全局的变量对象。在 f2 执行时，按照 作用域链查找，能查找到 f1 和 全局的变量或函数
*/

```

